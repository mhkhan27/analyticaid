% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_sheets.R
\name{read_sheets}
\alias{read_sheets}
\title{Read and Clean Multiple Excel Sheets with Automated Type Fixing}
\usage{
read_sheets(
  dataset_path,
  sheets = "all",
  remove_all_NA_col = TRUE,
  data_type_fix = TRUE,
  na_strings = c("", "NA", "N/A", " "),
  character_cols = NULL
)
}
\arguments{
\item{dataset_path}{Character string. Path to the Excel file.}

\item{sheets}{Either \code{"all"} (default), a \strong{character vector} of sheet names,
or a \strong{numeric vector} of sheet indices.
\itemize{
\item Example: \code{sheets = "hh"}
\item Example: \code{sheets = 1}
The function ensures proper validation and resolves numeric indices to
sheet names internally.
}}

\item{remove_all_NA_col}{Logical. If \code{TRUE}, columns with all \code{NA} values are
removed after reading. Default is \code{TRUE}.}

\item{data_type_fix}{Logical. If \code{TRUE}, the function applies
\code{fix_data_type()} to standardize variable types. Default is \code{TRUE}.}

\item{na_strings}{Character vector. Strings to be treated as missing values
during sheet import. Default is \code{c("", "NA", "N/A", " ")}.}

\item{character_cols}{Optional character vector. Column names that should
always be treated as character even during type fixing.}
}
\value{
\itemize{
\item If \strong{one} sheet is selected, the function returns a \strong{data.frame}.
\item If \strong{multiple} sheets are selected, the function returns a \strong{named list}
of cleaned data.frames (list element names match the sheet names).
}
}
\description{
\code{read_sheets()} reads one or more sheets from an Excel file and applies a set
of standard cleaning operations such as:
\itemize{
\item renaming problematic column names,
\item converting underscores-prefixed columns (e.g., Kobo) to safe names,
\item fixing data types using \code{fix_data_type()},
\item removing columns that contain only \code{NA}.
}
}
\details{
The function supports selecting sheets either by \strong{name} (e.g., \code{"hh"})
or by \strong{index} (e.g., \code{1}), making it versatile for different workflows.

The function performs several cleaning steps for each sheet:

\enumerate{
\item Reads the sheet using \code{read.xlsx()} from \code{openxlsx} with custom NA handling.
\item Replaces slashes (\code{/}) in column names with dots (\code{.}).
\item Detects Kobo-style underscore-prefixed columns (e.g., \code{"_id"})
and renames them to safe names (\code{"X_id"}).
\item Optionally applies \code{fix_data_type()} for automatic type coercion.
\item Optionally removes columns with all missing values.
}

Sheets can be selected in three different ways:
\itemize{
\item \code{"all"} — read all sheets in the file.
\item By name — e.g., \code{sheets = c("hh", "indv")}.
\item By index — e.g., \code{sheets = 1:2}.
}
}
\examples{
\dontrun{
# Read all sheets
read_sheets("survey.xlsx")

# Read one sheet by name
hh <- read_sheets("survey.xlsx", sheets = "hh")

# Read one sheet by index
hh <- read_sheets("survey.xlsx", sheets = 1)

# Read specific sheets by name
data_list <- read_sheets("survey.xlsx", sheets = c("hh", "indv"))

# Disable type fixing
read_sheets("survey.xlsx", data_type_fix = FALSE)
}

}
\seealso{
\code{\link{fix_data_type}} for automated data type cleaning.
}
